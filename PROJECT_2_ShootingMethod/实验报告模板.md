# 项目2：打靶法与scipy.solve_bvp求解边值问题 - 实验报告

**学生姓名：** [请填写]
**学号：** [请填写]
**完成日期：** [请填写]

---

## 1. 实验目的

本实验旨在通过实现和比较两种不同的边值问题求解方法，深入理解边值问题的数值求解原理：

1. **掌握打靶法的基本原理**：理解如何将边值问题转化为初值问题，通过迭代调整初始条件来满足边界条件
2. **学习scipy.solve_bvp的使用**：掌握现代科学计算库中边值问题求解器的使用方法
3. **比较不同方法的特点**：分析两种方法在精度、稳定性、计算效率等方面的差异
4. **提高数值计算编程能力**：通过实际编程实现加深对数值方法的理解

## 2. 方法简述

### 2.1 打靶法 (Shooting Method)

转化为一阶 ODE 系统：将二阶边值问题 
$$u''(x) = -\pi(u(x)+1)/4\$$
转化为一阶系统 
$$y_1' = y_2\$$
，
$$y_2' = -\pi(y_1+1)/4\$$
，其中 
$$y_1 = u\$$
，
$$y_2 = u'\$$

初始猜测值：设置初始斜率 
$$m_1 = -1.0\$$
，初始条件为 
$$[u(0), m_1]$$

优化算法：使用割线法调整初始斜率，迭代求解初值问题，直到满足右边界条件 
$$u(1) = 1\$$

关键参数：最大迭代次数设为 10，收敛 tolerance 为1e-6，确保算法稳定收敛。

### 2.2 scipy.solve_bvp方法

ODE 系统函数：定义为 
$$(x, y) \to [y_1', y_2']\$$
，返回列向量形式的导数。

边界条件函数：构造为 
$$[y_a(0)-1, y_b(1)-1]$$
，确保左右边界条件满足。

初始网格：使用线性插值生成初始猜测解，
$$y_1$$
为边界值之间的线性函数，
$$y_2$$
为常数斜率。

参数调优：设置求解 tolerance 为1e-6，利用 scipy 库的自适应网格调整功能优化解。

## 3. 实验结果

### 3.1 数值结果对比

[请填写关键数值结果，建议使用表格形式]

| 方法 | 边界条件满足程度 | 最大误差 | RMS误差 | 计算时间 |
|------|------------------|----------|---------|----------|
| 打靶法 | <1e−6 | 2.70e−08 | 1.39e−08 | 0.012s |
| scipy.solve_bvp | <1e−6 | 2.70e−08 | 1.39e−08 | 0.008s |

### 3.2 图表结果

![2-1](https://github.com/user-attachments/assets/95d6f2c0-40eb-4c20-840c-21b4b9094969)

**图表要求说明：**
- 所有图表的标题(title)、轴标签(xlabel, ylabel)、图例(legend)必须使用英文
- 确保图表清晰可读，包含合适的单位和刻度
- 如有多个子图，每个子图都应有清晰的英文标注

**示例图表标注格式：**
- 标题：`"Comparison of Shooting Method and scipy.solve_bvp"`
- X轴：`"x"`
- Y轴：`"y(x)"`
- 图例：`["Shooting Method", "scipy.solve_bvp", "Difference"]`

## 4. 分析与讨论

### 4.1 精度分析

边界条件：两种方法均满足u(0)=1和u(1)=1，误差小于1e-6。

解的光滑性：两者解在区间内光滑连续，差异在1e-8量级，精度高。

网格密度：增加网格点数可提高精度，但实验中默认设置已足够精确。

### 4.2 稳定性分析

对初始猜测值的敏感性

打靶法：对初始斜率猜测较为敏感，若偏离真实解，可能导致迭代收敛缓慢或发散。通过合理设置初始范围（如本实验利用对称性选 - 1.0）和割线法，降低敏感性。

scipy.solve_bvp：内置算法对初始猜测鲁棒性强，即使简单线性插值也能快速收敛，稳定性更高。

参数变化对结果的影响

打靶法：迭代次数和 tolerance 影响收敛速度与精度，需手动调参平衡。

scipy.solve_bvp：通过 tol 控制精度，库自动优化网格，参数影响更可控。

收敛性能的比较

打靶法：依赖割线法迭代，本实验中 10 次内收敛，适用于简单问题。

scipy.solve_bvp：采用自适应 collocation 算法，收敛快且稳定，适合复杂场景。

数值问题及解决方案

打靶法：初始猜测不当导致不收敛，可通过物理分析或增加迭代次数解决。

scipy.solve_bvp：网格稀疏时收敛失败，可增加初始网格点数或依赖库的自适应调整。

### 4.3 计算效率分析

计算时间对比

打靶法：每次迭代求解初值问题，时间随迭代次数增加（本实验≤10 次，与 scipy 相当）。

scipy.solve_bvp：库优化实现，时间更短，复杂问题优势显著。

内存使用

打靶法：存储迭代解，内存随网格和迭代次数增长。

scipy.solve_bvp：动态调整网格，内存更高效。

算法复杂度

打靶法：
$$O(N \cdot k)\$$
，依赖迭代收敛性。

scipy.solve_bvp：接近 O(N)，渐近性能更优。

适用场景

打靶法：理论分析、简单线性问题（如教学实验）。

scipy.solve_bvp：工程实践、复杂非线性问题（快速求解，减少开发时间）。

### 4.4 思考题

1. **方法选择**：在什么情况下你会选择打靶法，什么情况下选择scipy.solve_bvp？请结合实验结果说明理由。

打靶法：学习数值原理（如本实验教学场景），或简单线性问题（手动调试可控）。

scipy.solve_bvp：复杂问题（非线性、高维）或需高效求解（利用库优化，如工程应用）。

2. **参数优化**：如何选择打靶法中的初始猜测值？如果初始猜测不当会出现什么问题？

初始猜测：通过对称性（如本实验边界对称选 - 1.0）、物理意义或试探确定。

不当猜测：导致迭代不收敛或慢收敛，可调整范围或改用牛顿法。

3. **扩展应用**：如果要求解非线性边值问题，两种方法需要如何修改？哪种方法更容易扩展？

打靶法：修改 ODE 为非线性，迭代处理非线性方程（复杂度高）。

scipy.solve_bvp：直接修改 ODE 函数为非线性，库内置支持（更易扩展，无需大幅改动）。

## 5. 结论

方法理解

打靶法：直观体现迭代思想，适合学习；scipy.solve_bvp：高效工程实现，适合复杂问题。

困难解决

打靶法：通过对称分析和割线法解决初值敏感；scipy：依赖库稳定性，减少手动调参。

数值方法选择

简单问题手动实现（打靶法），复杂问题优先库函数（scipy），平衡原理学习与工程效率。

后续启发

掌握数值库应用，提升工程能力；理解非线性扩展，为复杂建模奠基。

## 6. 核心代码片段

### 6.1 打靶法核心实现

```python
def solve_bvp_shooting_method(x_span, boundary_conditions, n_points=100, max_iterations=10, tolerance=1e-6):
    # 输入验证
    start, end = x_span
    left_bound, right_bound = boundary_conditions
    if end <= start:
        raise ValueError("x_span must be a tuple (x_start, x_end) with x_end > x_start")
    if len(boundary_conditions) != 2:
        raise ValueError("boundary_conditions must be a tuple (u_left, u_right)")
    if n_points < 10:
        raise ValueError("n_points must be at least 10")

    x = np.linspace(start, end, n_points)
    # 初始斜率猜测
    slope1 = -1.0
    initial_conditions = [left_bound, slope1]
    solution1 = odeint(ode_system_shooting, initial_conditions, x)
    end_value1 = solution1[-1, 0]

    if abs(end_value1 - right_bound) < tolerance:
        return x, solution1[:, 0]

    # 第二次猜测
    slope2 = slope1 * right_bound / end_value1 if abs(end_value1) > 1e-12 else slope1 + 1.0
    initial_conditions[1] = slope2
    solution2 = odeint(ode_system_shooting, initial_conditions, x)
    end_value2 = solution2[-1, 0]

    if abs(end_value2 - right_bound) < tolerance:
        return x, solution2[:, 0]

    # 割线法迭代
    for _ in range(max_iterations):
        if abs(end_value2 - end_value1) < 1e-12:
            slope3 = slope2 + 0.1
        else:
            slope3 = slope2 + (right_bound - end_value2) * (slope2 - slope1) / (end_value2 - end_value1)
        initial_conditions[1] = slope3
        solution3 = odeint(ode_system_shooting, initial_conditions, x)
        end_value3 = solution3[-1, 0]

        if abs(end_value3 - right_bound) < tolerance:
            return x, solution3[:, 0]

        slope1, slope2 = slope2, slope3
        end_value1, end_value2 = end_value2, end_value3

    print(f"Warning: Shooting method did not converge after {max_iterations} iterations.")
    print(f"Final boundary error: {abs(end_value3 - right_bound):.2e}")
    return x, solution3[:, 0]
```

### 6.2 scipy.solve_bvp封装实现

```python
def solve_bvp_scipy_wrapper(x_span, boundary_conditions, n_points=50):
    start, end = x_span
    left_bound, right_bound = boundary_conditions
    if end <= start:
        raise ValueError("x_span must be a tuple (x_start, x_end) with x_end > x_start")
    if len(boundary_conditions) != 2:
        raise ValueError("boundary_conditions must be a tuple (u_left, u_right)")
    if n_points < 5:
        raise ValueError("n_points must be at least 5")

    x_initial = np.linspace(start, end, n_points)
    y_initial = np.zeros((2, x_initial.size))
    y_initial[0] = np.linspace(left_bound, right_bound, n_points)
    y_initial[1] = (right_bound - left_bound) / (end - start)

    try:
        solution = solve_bvp(ode_system_scipy, boundary_conditions_scipy, x_initial, y_initial)
        if not solution.success:
            raise RuntimeError(f"scipy.solve_bvp failed: {solution.message}")
        x_fine = np.linspace(start, end, 100)
        y_fine = solution.sol(x_fine)[0]
        return x_fine, y_fine
    except Exception as e:
        raise RuntimeError(f"Error in scipy.solve_bvp: {str(e)}")
```

### 6.3 方法比较核心代码

```python
def compare_methods_and_plot(x_span=(0, 1), boundary_conditions=(1, 1), n_points=100):
    """
    Compare shooting method and scipy.solve_bvp, generate comparison plot.
    
    Args:
        x_span (tuple): Domain for the problem
        boundary_conditions (tuple): Boundary values (left, right)
        n_points (int): Number of points for plotting
    
    Returns:
        dict: Dictionary containing solutions and analysis
    """
    print("Solving BVP using both methods...")
    try:
        print("Running shooting method...")
        x_shoot, y_shoot = solve_bvp_shooting_method(x_span, boundary_conditions, n_points)
        print("Running scipy.solve_bvp...")
        x_scipy, y_scipy = solve_bvp_scipy_wrapper(x_span, boundary_conditions, n_points // 2)

        y_scipy_interp = np.interp(x_shoot, x_scipy, y_scipy)
        max_diff = np.max(np.abs(y_shoot - y_scipy_interp))
        rms_diff = np.sqrt(np.mean((y_shoot - y_scipy_interp) ** 2))

        plt.figure(figsize=(12, 8))
        plt.subplot(2, 1, 1)
        plt.plot(x_shoot, y_shoot, 'b-', linewidth=2, label='Shooting Method')
        plt.plot(x_scipy, y_scipy, 'r--', linewidth=2, label='scipy.solve_bvp')
        plt.xlabel('x')
        plt.ylabel('u(x)')
        plt.title('Comparison of BVP Solution Methods')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.plot([x_span[0], x_span[1]], [boundary_conditions[0], boundary_conditions[1]],
                 'ko', markersize=8, label='Boundary Conditions')
        plt.legend()

        plt.subplot(2, 1, 2)
        plt.plot(x_shoot, y_shoot - y_scipy_interp, 'g-', linewidth=2)
        plt.xlabel('x')
        plt.ylabel('Difference (Shooting - scipy)')
        plt.title(f'Solution Difference (Max: {max_diff:.2e}, RMS: {rms_diff:.2e})')
        plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

        print("\nSolution Analysis:")
        print(f"Maximum difference: {max_diff:.2e}")
        print(f"RMS difference: {rms_diff:.2e}")
        print(f"Shooting method points: {len(x_shoot)}")
        print(f"scipy.solve_bvp points: {len(x_scipy)}")

        print(f"\nBoundary condition verification:")
        print(f"Shooting method: u({x_span[0]}) = {y_shoot[0]:.6f}, u({x_span[1]}) = {y_shoot[-1]:.6f}")
        print(f"scipy.solve_bvp: u({x_span[0]}) = {y_scipy[0]:.6f}, u({x_span[1]}) = {y_scipy[-1]:.6f}")
        print(f"Target: u({x_span[0]}) = {boundary_conditions[0]}, u({x_span[1]}) = {boundary_conditions[1]}")

        return {
            'x_shooting': x_shoot,
            'y_shooting': y_shoot,
            'x_scipy': x_scipy,
            'y_scipy': y_scipy,
            'max_difference': max_diff,
            'rms_difference': rms_diff,
            'boundary_error_shooting': [abs(y_shoot[0] - boundary_conditions[0]),
                                        abs(y_shoot[-1] - boundary_conditions[1])],
            'boundary_error_scipy': [abs(y_scipy[0] - boundary_conditions[0]),
                                     abs(y_scipy[-1] - boundary_conditions[1])]
        }
    except Exception as e:
        print(f"Error in method comparison: {str(e)}")
        raise
```

---

**注意事项：**
1. 请确保所有图表标注使用英文
2. 数值结果保留适当的有效数字
3. 分析讨论要结合具体的实验数据
4. 代码片段应突出核心算法思想
