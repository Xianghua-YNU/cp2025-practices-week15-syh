# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** [在此处填写你的姓名]
**学号：** [在此处填写你的学号]
**完成日期：** [在此处填写完成日期]

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
将连续微分方程离散化为线性方程组。使用中心差分近似 
$$y''\((y_{i+1}-2y_i+y_{i-1})/h^2\)$$
和 
$$y'\((y_{i+1}-y_{i-1})/(2h)\)$$
，构建系数矩阵 A。处理边界条件（左边界 
$$y_0=0\$$
代入左端，右边界 
$$y_{n+1}=3\$$
代入右端），求解 
$$A\mathbf{y}=\mathbf{b}\$$
得到内部解，再组合边界值。

**关键代码片段 (可选)：**
```python
class FiniteDifferenceSolver(BVPSolver):
    """有限差分法求解器"""
    
    def solve(self, n_points: int) -> Tuple[np.ndarray, np.ndarray]:
        """使用有限差分法求解BVP"""
        # 创建网格
        h = (self.x_end - self.x_start) / (n_points + 1)
        x_grid = np.linspace(self.x_start, self.x_end, n_points + 2)
        
        # 构建线性方程组
        A = np.zeros((n_points, n_points))
        b = np.zeros(n_points)
        
        # 填充系数矩阵和右端向量
        for i in range(n_points):
            x_i = x_grid[i + 1]  # 内部点
            
            # 中心差分近似
            a = 1/h**2 - np.sin(x_i)/(2*h)
            b_center = -2/h**2 + np.exp(x_i)
            c = 1/h**2 + np.sin(x_i)/(2*h)
            
            # 填充矩阵
            if i > 0:
                A[i, i-1] = a
            A[i, i] = b_center
            if i < n_points - 1:
                A[i, i+1] = c
            
            # 填充右端向量
            b[i] = x_i**2
            
            # 处理边界条件
            if i == 0:
                b[i] -= a * self.y_start
            if i == n_points - 1:
                b[i] -= c * self.y_end
        
        # 求解线性方程组
        y_inner = np.linalg.solve(A, b)
        
        # 组合完整解
        y_solution = np.zeros(n_points + 2)
        y_solution[0] = self.y_start
        y_solution[1:-1] = y_inner
        y_solution[-1] = self.y_end
        
        return x_grid, y_solution
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
定义一阶 ODE 系统（
$$[y, y']$$
的导数）和边界条件函数（
$$y(0)=0, y(5)=3$$
）。设置初始网格（如 
$$n=11$$
点）和初始猜测（分段函数，模拟解的趋势），调用 solve_bvp。若收敛失败，切换打靶法（优化初始斜率，通过 solve_ivp 求解初值问题）。

**关键代码片段 (可选)：**
```python
class ScipyBVPSolver(BVPSolver):
    """基于scipy的BVP求解器"""
   
    def _solve_with_solve_bvp(self, n_initial_points: int) -> Tuple[np.ndarray, np.ndarray]:
        """使用scipy.integrate.solve_bvp求解"""
        # 创建初始网格
        x_initial = np.linspace(self.x_start, self.x_end, n_initial_points)
        
        # 基于物理特性的智能初始猜测
        y_initial = np.zeros((2, n_initial_points))
        
        # 设计分段初始猜测
        for i, x in enumerate(x_initial):
            # 左侧区域：使用抛物线形状
            if x < (self.x_start + self.x_end) / 3:
                y_initial[0, i] = self.y_start + (self.y_end - self.y_start) * (x / self.x_end)**2
                y_initial[1, i] = 2 * (self.y_end - self.y_start) * x / (self.x_end**2)
            # 右侧区域：使用线性插值
            else:
                slope = (self.y_end - self.y_start) / (self.x_end - self.x_start)
                y_initial[0, i] = self.y_start + slope * (x - self.x_start)
                y_initial[1, i] = slope
        
        # 求解BVP
        solution = solve_bvp(
            self.ode_func, 
            self.bc_func, 
            x_initial, 
            y_initial,
            tol=1e-8,
            max_nodes=10000
        )
        
        if not solution.success:
            raise RuntimeError(f"solve_bvp failed: {solution.message}")
        
        # 在密集网格上获取解
        x_solution = np.linspace(self.x_start, self.x_end, 500)
        y_solution = solution.sol(x_solution)[0]
        
        return x_solution, y_solution
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

![1-1](https://github.com/user-attachments/assets/3f5398a7-2d7e-4df0-9ea7-55cf12f1908f)

**(图片粘贴区域)**

### 3.2 结果比较与讨论

方法差异：有限差分法结果（如x=1.0处y=-19.92）与 solve_bvp(y=-29.82)存在偏差，源于离散化精度（有限差分固定网格，solve_bvp 自适应网格）和初始条件设置。

参数影响：离散点数n=100时，有限差分法精度随 n 增加提升（网格加密）；solve_bvp 初始猜测（如线性插值）对收敛至关重要，本实验通过分段猜测提高了稳定性。

边界处理：有限差分法在矩阵中直接嵌入边界，solve_bvp 通过边界函数显式约束，后者更灵活但对初始值敏感。

### 3.3 (可选) 精度分析

通过调整 solve_bvp 的 tol(1e-8)和初始猜测（分段函数），提升了精度，最终通过测试用例的边界条件验证（
$$y(0)\approx0, y(5)\approx3$$
）。

## 4.遇到的问题与解决方法

**主要问题：**
solve_bvp 初始猜测差导致收敛失败。

**解决方法：**
设计分段初始猜测（模拟解的趋势，如线性 + 抛物线组合），并添加打靶法作为后备，确保求解鲁棒性。

## 5. 总结与心得体会

**主要收获：**
掌握了有限差分法的离散化和线性方程组求解，理解其网格依赖性。
学会使用 scipy 工具包，体会到数值方法的灵活性（自适应网格、打靶法）。
提升了代码调试能力，通过优化初始条件和求解参数，改进解的精度。
认识到不同方法的适用场景：有限差分法适合规则网格，solve_bvp 更通用但需合理设置初始值。

